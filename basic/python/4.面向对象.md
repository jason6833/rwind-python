# 面向对象

## 类

* 结构图

    <img src="./imgs/76.png" width="500px"/>

### 类的定义

* 类的定义

    ```python
    class Student():
        name = ''
        age = 10

        def print_file(self):
            print(self.name)
            print(self.age)
    ```

* 类的实例化

    ```python
    student = Student()
    student.print_file()
    ```

### 类与对象

* 类和对象的关系就是通过实例化来关联在一起的

    ```python
    student = Student()
    student.print_file()
    ```

* 类是现实世界或思维世界中的实体在计算机中的反映，它将`数据`以及这些数据上的`操作`封装在一起

### 构造函数

* 构造函数

    ```python
    class Student():
        name = ''
        age = 0

        def __init__(self):
            print("student")
        def do_homework(self):
            print("homework")

    student1 = Student()# 构造函数的调用是自动进行的，当实例化的时候，python自动调用构造函数
    student1.__init__()# 可以主动的显式调用__init__方法，调用之后返回值为None，此时这个方法和普通方法一样，在实际编程中，很少这样做
    ```

    * 对于构造函数来说，是不能返回除None之外的任何类型的类型值的，只能返回None

* 示例代码

    ```python
    class Student():
        name = ''
        age = 0

        def __init__(self, name, age):
            self.name = name
            self.age = age

        def do_homework(self):
            print("homework")


    student1 = Student("li", 12)
    print(student1.name)
    ```

### 成员变量

* 模块全局变量、模块局部变量

    ```python
    c = 50

    def add(x, y):
        c = x + y# 新定义的c变量，和全局变量c不是同一个变量，这个c的作用域仅仅局限在函数的内部，全局变量的值不会因为局部变量而更改
        print(c)

    add(1, 2)
    print(c)

    # 3
    # 50
    ```

    * 可以很明显的看到，如果函数定义了一个和全局变量同名的变量的话，局部的变量并不会覆盖全局的变量

* 类变量、实例变量

    * 类变量：和类相关的变量，和类关联到一起，类的内部方法之外的变量是类变量，不是实例变量

    * 实例变量：和对象相关联在一起的，实例变量的定义方法：就是使用self这样的关键字再加上变量的名字

    ```python
    class Student():
        # 类变量
        name = 'qiyue'
        age = 0

        def __init__(self, name, age):
            # 实例变量，只和实例相关，和类没有关系
            self.name = name
            self.age = age

        def do_homework(self):
            print("homework")

    student1 = Student("li", 12)
    student2 = Student("zhou",13)
    print(student1.name)
    print(student2.name)
    print(Student.name)
    ```

* 类变量、实例变量查找顺序

    ```python
    class Student():
        # 类变量
        name = 'qiyue'
        age = 0

        def __init__(self, name, age):
            # 实例变量，只和实例相关，和类没有关系
            name = name
            age = age

        def do_homework(self):
            print("homework")

    student1 = Student("li", 12)
    print(student1.__dict__) # {}
    print(studnet1.name) # qiyue
    print(Student.name) # qiyue
    print(Student.__dict__)
    ```

    * 如果我们尝试去访问一个对象实例的实例变量的话，那么python会首先在对象的实例变量列表里面去查找有没有这样的变量，如果没有的话，python并不会返回一个空，他会继续到类变量列表里面去寻找该变量，这也就是为什么当访问student1下面的name实例变量的时候，他不存在，但是返回类变量值得原因，因为python会继续到类变量里面去寻找，他找到同名的name变量，将他返回回来，如果在类里面还没有找到，他会到Studen的父类里面去寻找

### self

* self就是当前调用某个实例方法的实例对象

* 如果要在类下面定义一个实例方法的话，那么必须在这个方法的参数列表的第一个位置固定放置一个self，也就是说对于类下面的实例方法默认会有一个python所规定的参数，他和我们自定义的参数是不同的

* 当我们调用实例方法的时候，不需要手动的传入self参数，这个参数是python默认为我们传入的参数

* self可以修改成任意需要的名字，但是位置必须是在实例方法参数列表的第一个位置

### 实例方法

* 实例方法也是和对象实例相关联的，也就是实例可以调用的方法，实例方法最大的特点就是他的第一个参数是需要传递一个self的

* 构造函数可以看做是一个特殊的实例方法，他和普通实例方法的区别只是调用方式不同而已，其他的特性和普通的实例方法一样，另外构造函数和实例方法的意义也不一样，实例方法主要用来描述对象实例的行为，而构造函数意义在与初始化类的各种数据特征的

* 实例方法访问类变量

    * 不要妄图在实例方法内部不通过self来访问实例变量，也不要想着不加任何的前缀来访问类变量，在实例方法内部可以通过类名加类变量的方式访问类的类变量

    ```python
    class Student():
        # 类变量
        sum = 0

        def __init__(self, name, age):
            # 实例变量，只和实例相关，和类没有关系
            self.name = name
            self.age = age
            print(Student.sum)
            print(self.__class__.sum) # 同上句

        def do_homework(self):
            print("homework")

    student1 = Student("li", 12)
    ```

    ```python
    class Student():
        # 类变量
        sum = 0

        def __init__(self, name, age):
            # 实例变量，只和实例相关，和类没有关系
            self.name = name
            self.age = age
            # 访问类变量
            self.__class__.sum += 1

        def do_homework(self):
            print("homework")


    student1 = Student("li", 12)
    student2 = Student("li", 12)
    print(Student.sum)
    ```

### 类方法

* 类方法定义

    * 类方法和实例方法一样，他的参数列表第一个参数也有一个固定的参数

    * 决定一个方法是类方法还是实例方法，根本方式是看在这个方法上面是不是有装饰器`@classmethod`，而不是看参数列表第一个参数的名字

    * 类方法的主要作用是用来操作和类相关的一些变量

    ```python
    class Student():
        # 类变量
        sum = 0

        def __init__(self, name, age):
            # 实例变量，只和实例相关，和类没有关系
            self.name = name
            self.age = age

        def do_homework(self):
            print("homework")

        # 类方法
        @classmethod
        def plus_sum(cls):
            # 访问类变量
            cls.sum += 1
            print(cls.sum)


    student1 = Student("li", 12)
    Student.plus_sum()
    student2 = Student("li", 12)
    Student.plus_sum()
    ```

### 静态方法

* 静态方法的上面也要有一个装饰器`@staticmethod`

* 静态方法没有像类方法和实例方法一样必须要传递一个固定参数，他的参数列表可以为空，什么都不传递

* 实例对象和类都可以调用静态方法

* 静态方法内部也是可以访问类变量的

* 静态方法和类方法内部无法访问实例变量

* 建议静态方法不要经常使用，能用静态方法的地方都可以用类方法替换，而且使用类方法更加方便

    ```python
    class Student():
        # 类变量
        sum = 0

        def __init__(self, name, age):
            # 实例变量，只和实例相关，和类没有关系
            self.name = name
            self.age = age

        def do_homework(self):
            print("homework")

        # 类方法
        @classmethod
        def plus_sum(cls):
            cls.sum += 1
            print(cls.sum)

        @staticmethod
        def add(x, y):
            print("this is a static method")


    student1 = Student("li", 12)
    student1.add(1, 2)
    Student.add(3, 4)
    ```

### 成员可见性

* 阻止其他人从类的外部直接对实例的实例变量进行修改赋值以及读取操作

    * 公开的 public，如果成员是公开的，那么我们就可以在类的外部来直接访问
    
    * 私有的 private，如果成员是私有的，那么我们在类的外部是无法直接进行读取和赋值操作的

    * 成员的名字以两个下划线开头，python就认为该成员是私有的，反之，都是公开的，如果后面再加上两个下划线，就和构造函数一样了，外部也是可以访问的，就不再是私有的了，一般而言，前后都加上下划线的成员都是python内置的成员，我们自己的代码只要前面加双下划线即可

    ```python
    class Student():
        # 类变量
        sum = 0

        def __init__(self, name, age):
            # 实例变量，只和实例相关，和类没有关系
            self.name = name
            self.age = age
            self.__score = 0

        def marking(self, score):
            self.__score = score
            print(self.name + "的成绩是" + str(self.score))

        def do_homework(self):
            print("homework")

        # 类方法
        @classmethod
        def plus_sum(cls):
            cls.sum += 1
            print(cls.sum)


    student1 = Student("li", 12)
    print(student1.__score)#访问不到该成员
    student1.marking(12)
    ```

* 没有什么是不能访问的

    ```python
    class Student():
        # 类变量
        sum = 0

        def __init__(self, name, age):
            # 实例变量，只和实例相关，和类没有关系
            self.name = name
            self.age = age
            self.__score = 0

        def marking(self, score):
            self.__score = score
            print(self.name + "的成绩是" + str(self.__score))

        def do_homework(self):
            print("homework")

        # 类方法
        @classmethod
        def plus_sum(cls):
            cls.sum += 1
            print(cls.sum)


    student1 = Student("li", 12)
    student1.marking(10)
    student1.__score = -1#这里实际上是给实例对象新增了一个__score属性
    print(student1.__score)#-1
    print(student1.__dict__)#{'name': 'li', 'age': 12, '_Student__score': 10, '__score': -1}
    ```

    * 所以动态的添加私有变量是不可以的，python对私有变量的保护只是将私有变量的名字进行了修改，严格意义上来讲，python是没有私有变量的

## 继承

